# File Structure and Contents

## /auto-audio-mixer-v2/

## /auto-audio-mixer-v2/auto-audio-mixer-v2.psd1

```psd1
#
# Module manifest for module 'auto-audio-mixer-v2'
#
# Generated by: roulendz
#
# Generated on: 1/27/2025
#

@{

# Script module or binary module file associated with this manifest.
RootModule = 'auto-audio-mixer-v2.psm1'

# Version number of this module.
ModuleVersion = '1.0.0'

# Supported PSEditions
# CompatiblePSEditions = @()

# ID used to uniquely identify this module
GUID = '9f883c82-55f2-49e8-8ee5-1244b4995a2f'

# Author of this module
Author = 'roulendz'

# Company or vendor of this module
CompanyName = 'Unknown'

# Copyright statement for this module
Copyright = '(c) 2025 roulendz. All rights reserved.'

# Description of the functionality provided by this module
Description = 'Audio processing and mixing automation module'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '6.0'

# Name of the Windows PowerShell host required by this module
# PowerShellHostName = ''

# Minimum version of the Windows PowerShell host required by this module
# PowerShellHostVersion = ''

# Minimum version of Microsoft .NET Framework required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# DotNetFrameworkVersion = ''

# Minimum version of the common language runtime (CLR) required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# CLRVersion = ''

# Processor architecture (None, X86, Amd64) required by this module
# ProcessorArchitecture = ''

# Modules that must be imported into the global environment prior to importing this module
# RequiredModules = @()

# Assemblies that must be loaded prior to importing this module
# RequiredAssemblies = @()

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
# ScriptsToProcess = @()

# Type files (.ps1xml) to be loaded when importing this module
# TypesToProcess = @()

# Format files (.ps1xml) to be loaded when importing this module
# FormatsToProcess = @()

# Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
# NestedModules = @()

# Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
FunctionsToExport = '*'

# Cmdlets to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no cmdlets to export.
CmdletsToExport = '*'

# Variables to export from this module
VariablesToExport = '*'

# Aliases to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no aliases to export.
AliasesToExport = '*'

# DSC resources to export from this module
# DscResourcesToExport = @()

# List of all modules packaged with this module
# ModuleList = @()

# List of all files packaged with this module
# FileList = @()

# Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
PrivateData = @{

    PSData = @{

        # Tags applied to this module. These help with module discovery in online galleries.
        # Tags = @()

        # A URL to the license for this module.
        # LicenseUri = ''

        # A URL to the main website for this project.
        # ProjectUri = ''

        # A URL to an icon representing this module.
        # IconUri = ''

        # ReleaseNotes of this module
        # ReleaseNotes = ''

    } # End of PSData hashtable

} # End of PrivateData hashtable

# HelpInfo URI of this module
# HelpInfoURI = ''

# Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
# DefaultCommandPrefix = ''

}


```

---

## /auto-audio-mixer-v2/auto-audio-mixer-v2.psm1

```psm1
# Optimized version of auto-audio-mixer-v2.psm1
using namespace System.Management.Automation

# Import required functions at module scope
$modulePath = Split-Path -Parent $MyInvocation.MyCommand.Path
@(
    'src/Core/Types/AudioTypes.psm1',
    'src/Core/Utils/ErrorHandling.psm1',
    'src/Audio/Analysis/VolumeAnalyzer.psm1',
    'src/IO/MetadataManager.psm1',
    'src/Audio/Processing/Compressor.psm1'
) | ForEach-Object {
    $fullPath = Join-Path $modulePath $_
    if (Test-Path $fullPath) {
        Import-Module $fullPath -Force
    }
    else {
        Write-Warning "Module not found: $_"
    }
}

function Invoke-AudioProcessing {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$FolderPath,
        
        [Parameter()]
        [int]$ThrottleLimit = 4,
        
        [Parameter()]
        [switch]$Force
    )

    begin {
        Write-Verbose "Starting audio processing for folder: $FolderPath"
        Set-StrictMode -Version Latest
    }

    process {
        # Validate folder and FFmpeg
        if (-not (Test-Path -Path $FolderPath -PathType Container)) {
            throw [System.IO.DirectoryNotFoundException]::new("The specified folder does not exist: $FolderPath")
        }

        if (-not (Test-FFmpegAvailable)) {
            throw [System.InvalidOperationException]::new("FFmpeg is required but not available")
        }

        # Get .wav files
        $wavFiles = Get-ChildItem -Path $FolderPath -Filter "*.wav" | 
            Where-Object { ($_.Name -match "Pastor_|Radio1_") -and ($_.Name -notmatch "_automix") }

        if (-not $wavFiles) {
            Write-Warning "No matching .wav files found."
            return
        }

        # Create initial metadata path
        $timestamp = Get-Date -Format 'yyyyMMddHHmmss'
        $metadataPath = Join-Path $FolderPath "metadata_$timestamp.json"

        # Process files in parallel and collect results
        $results = $wavFiles | ForEach-Object -ThrottleLimit $ThrottleLimit -Parallel {
            $file = $_
            $filePath = $file.FullName
            $fileName = $file.Name
            
            try {
                Write-Host "Processing file: $fileName" -ForegroundColor Cyan
                
                # Load required functions in parallel scope
                $moduleFunctions = {
                    function Get-AudioVolumeStats {
                        param ([string]$FilePath)
                        $volumeLog = [System.IO.Path]::ChangeExtension($FilePath, ".volumedetect.log")
                        try {
                            $ffmpegOutput = & ffmpeg -i $FilePath -af "volumedetect" -f null NUL 2>&1
                            $null = $ffmpegOutput | Out-File -FilePath $volumeLog -Encoding utf8
                            
                            $meanVolume = [double](Select-String -Path $volumeLog -Pattern "mean_volume: (-?\d+\.?\d*) dB" | 
                                ForEach-Object { $_.Matches.Groups[1].Value })
                            $maxVolume = [double](Select-String -Path $volumeLog -Pattern "max_volume: (-?\d+\.?\d*) dB" | 
                                ForEach-Object { $_.Matches.Groups[1].Value })
                            
                            return @{
                                MeanVolume = $meanVolume
                                MaxVolume = $maxVolume
                                MinVolume = -100.0  # Default value
                                FixMeanVolume = [Math]::Min($meanVolume + 27.4, 0.0)
                                RequiresCompression = ($maxVolume - (-100.0)) -gt 40.0 -or $meanVolume -lt -24.0
                            }
                        }
                        finally {
                            if (Test-Path $volumeLog) {
                                Remove-Item -Path $volumeLog -Force
                            }
                        }
                    }

                    function Invoke-AudioCompression {
                        param (
                            [string]$InputPath,
                            [double]$Threshold
                        )
                        
                        $directory = [System.IO.Path]::GetDirectoryName($InputPath)
                        $filename = [System.IO.Path]::GetFileNameWithoutExtension($InputPath)
                        $extension = [System.IO.Path]::GetExtension($InputPath)
                        $timestamp = Get-Date -Format 'yyyyMMddHHmmss'
                        $outputPath = Join-Path $directory ($filename + "_automixd_$timestamp" + $extension)

                        $ffmpegArgs = @(
                            "-i", $InputPath,
                            "-af", "acompressor=threshold=${Threshold}dB:ratio=20:attack=5:release=200",
                            $outputPath
                        )

                        $result = & ffmpeg $ffmpegArgs 2>&1
                        if ($LASTEXITCODE -eq 0) {
                            return $outputPath
                        }
                        return $null
                    }
                }.ToString()

                Invoke-Expression $moduleFunctions
                
                # Analyze volume
                $volumeStats = Get-AudioVolumeStats -FilePath $filePath
                if (-not $volumeStats) {
                    throw "Failed to analyze volume"
                }

                # Create metadata entry
                $metadata = @{
                    FilePath = $filePath
                    VolumeStats = $volumeStats
                    ProcessingTimestamp = [datetime]::UtcNow
                }

                # Apply compression if needed
                $compressedPath = $null
                if ($volumeStats.RequiresCompression) {
                    $compressedPath = Invoke-AudioCompression `
                        -InputPath $filePath `
                        -Threshold $volumeStats.FixMeanVolume

                    if ($compressedPath) {
                        Write-Host "Compression complete: $compressedPath" -ForegroundColor Green
                    }
                }

                # Return both metadata and processing result
                return @{
                    Status = "Success"
                    File = $fileName
                    Metadata = $metadata
                    CompressedPath = $compressedPath
                }
            }
            catch {
                Write-Error "Error processing ${fileName}: $_"
                return @{
                    Status = "Error"
                    File = $fileName
                    Error = $_.Exception.Message
                }
            }
        }

        # Collect metadata from successful results
        $metadataCollection = @{}
        $successfulResults = @($results | Where-Object Status -eq "Success")
        foreach ($result in $successfulResults) {
            $metadataCollection[$result.File] = $result.Metadata
        }

        # Save metadata efficiently
        if ($successfulResults.Length -gt 0) {
            $metadataCollection | 
                ConvertTo-Json -Depth 10 | 
                Set-Content -Path $metadataPath -NoNewline -Encoding utf8
        }

        # Summarize results
        $successCount = @($results | Where-Object Status -eq "Success").Length
        $errorCount = @($results | Where-Object Status -eq "Error").Length

        Write-Host "`nProcessing Summary:" -ForegroundColor Cyan
        Write-Host "Successfully processed: $successCount files" -ForegroundColor Green
        if ($errorCount -gt 0) {
            Write-Host "Failed to process: $errorCount files" -ForegroundColor Red
            Write-Host "Failed files with errors:" -ForegroundColor Red
            $results | Where-Object Status -eq "Error" | ForEach-Object {
                Write-Host "- $($_.File) - $($_.Error)" -ForegroundColor Red
            }
        }
        
        if ($metadataCollection.Count -gt 0) {
            Write-Host "Metadata saved to: $metadataPath" -ForegroundColor Green
        }

        # Return results object for potential further processing
        return @{
            SuccessCount = $successCount
            ErrorCount = $errorCount
            MetadataPath = $metadataPath
            Results = $results
        }
    }
}

# Export only the main function
Export-ModuleMember -Function Invoke-AudioProcessing
```

---

## /auto-audio-mixer-v2/build.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/file_structure_content.md

*[No content available]*

---

## /auto-audio-mixer-v2/src/

## /auto-audio-mixer-v2/src/Audio/

## /auto-audio-mixer-v2/src/Audio/Analysis/

## /auto-audio-mixer-v2/src/Audio/Analysis/MetadataAnalyzer.psm1

```psm1
# /src/IO/MetadataManager.psm1
using namespace System.Management.Automation

function Save-AudioMetadata {
    [CmdletBinding()]
    [OutputType([string])]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $_ -PathType Container })]
        [string]$FolderPath,

        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [hashtable]$MetadataCollection
    )

    process {
        try {
            $outputPath = Join-Path $FolderPath "metadata_output.json"
            $MetadataCollection | ConvertTo-Json -Depth 10 | Out-File -FilePath $outputPath -Encoding utf8
            Write-Verbose "Metadata saved to $outputPath"
            return $outputPath
        }
        catch {
            Write-Error "Error saving metadata: $_"
            return $null
        }
    }
}

function Update-AudioMetadata {
    [CmdletBinding()]
    [OutputType([bool])]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $_ -PathType Leaf })]
        [string]$JsonPath,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$FileName,

        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [hashtable]$NewMetadata
    )

    process {
        try {
            $existingMetadata = Get-Content $JsonPath | ConvertFrom-Json | ConvertTo-Hashtable
            $existingMetadata[$FileName] = $NewMetadata

            $existingMetadata | ConvertTo-Json -Depth 10 | Out-File -FilePath $JsonPath -Encoding utf8
            Write-Verbose "Metadata updated for $FileName in $JsonPath"
            return $true
        }
        catch {
            Write-Error "Error updating metadata: $_"
            return $false
        }
    }
}

Export-ModuleMember -Function Save-AudioMetadata, Update-AudioMetadata

```

---

## /auto-audio-mixer-v2/src/Audio/Analysis/VolumeAnalyzer.psm1

```psm1
# /src/Audio/Analysis/VolumeAnalyzer.psm1
using namespace System.Management.Automation
using namespace System.IO

# Dependencies: AudioTypes.psm1 (AudioVolumeStats)

function Get-AudioVolumeStats {
    [CmdletBinding()]
    [OutputType([AudioVolumeStats])]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $_ -PathType Leaf })]
        [string]$FilePath
    )

    begin {
        Write-Verbose "Analyzing volume for file: $FilePath"
    }

    process {
        $volumeLog = [System.IO.Path]::ChangeExtension($FilePath, ".volumedetect.log")
        try {
            # Run FFmpeg volume detection
            $ffmpegOutput = & ffmpeg -i $FilePath -af "volumedetect" -f null NUL 2>&1
            $null = $ffmpegOutput | Out-File -FilePath $volumeLog -Encoding utf8

            # Extract mean and max volume from log
            $meanVolume = [double](Select-String -Path $volumeLog -Pattern "mean_volume: (-?\d+\.?\d*) dB" | 
                ForEach-Object { $_.Matches.Groups[1].Value })
            $maxVolume = [double](Select-String -Path $volumeLog -Pattern "max_volume: (-?\d+\.?\d*) dB" | 
                ForEach-Object { $_.Matches.Groups[1].Value })

            return [AudioVolumeStats]::new($meanVolume, $maxVolume, -100.0)  # Min volume defaulted
        }
        catch {
            Write-Error "Error analyzing volume: $_"
            return $null
        }
        finally {
            if (Test-Path $volumeLog) {
                Remove-Item -Path $volumeLog -Force
            }
        }
    }
}

Export-ModuleMember -Function Get-AudioVolumeStats

```

---

## /auto-audio-mixer-v2/src/Audio/Processing/

## /auto-audio-mixer-v2/src/Audio/Processing/Compressor.psm1

```psm1
# /src/Audio/Processing/Compressor.psm1
function Invoke-AudioCompression {
    [CmdletBinding()]
    [OutputType([string])]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $_ -PathType Leaf })]
        [string]$InputPath,

        [Parameter(Mandatory = $true)]
        [ValidateRange(-100, 0)]
        [double]$Threshold
    )

    begin {
        Write-Verbose "Starting audio compression for: $InputPath"
    }

    process {
        try {
            $directory = [System.IO.Path]::GetDirectoryName($InputPath)
            $filename = [System.IO.Path]::GetFileNameWithoutExtension($InputPath)
            $extension = [System.IO.Path]::GetExtension($InputPath)
            $outputPath = Join-Path $directory ($filename + "_automixd" + $extension)

            if (Test-Path $outputPath) {
                Write-Verbose "Removing existing output file: $outputPath"
                Remove-Item -Path $outputPath -Force
            }

            $ffmpegArgs = @(
                "-i", $InputPath,
                "-af", "acompressor=threshold=${Threshold}dB:ratio=20:attack=5:release=200",
                $outputPath
            )

            $result = & ffmpeg $ffmpegArgs 2>&1
            if ($LASTEXITCODE -ne 0) {
                throw "FFmpeg compression failed with exit code: $LASTEXITCODE"
            }

            Write-Verbose "Audio compression successful. Output: $outputPath"
            return $outputPath
        }
        catch {
            Write-Error "Error applying compression: $_"
            return $null
        }
    }
}

Export-ModuleMember -Function Invoke-AudioCompression

```

---

## /auto-audio-mixer-v2/src/Configuration/

## /auto-audio-mixer-v2/src/Configuration/Settings.psm1

*[No content available]*

---

## /auto-audio-mixer-v2/src/Core/

## /auto-audio-mixer-v2/src/Core/Types/

## /auto-audio-mixer-v2/src/Core/Types/AudioTypes.psm1

```psm1
using namespace System.Management.Automation

# Define enums for better type safety
enum AudioFileType {
    WAV
    MP3
    FLAC
    Unknown
}

enum ProcessingStage {
    Raw
    Analyzed
    Compressed
    Mixed
    Completed
    Error
}

# Enhanced AudioVolumeStats class with validation and additional properties
class AudioVolumeStats {
    [ValidateRange(-100.0, 0.0)]
    [double]$MeanVolume

    [ValidateRange(-100.0, 0.0)]
    [double]$MaxVolume

    [ValidateRange(-100.0, 0.0)]
    [double]$MinVolume

    [ValidateRange(-100.0, 100.0)]
    [double]$FixMeanVolume

    [bool]$RequiresCompression

    # Constructor with validation
    AudioVolumeStats([double]$mean, [double]$max, [double]$min) {
        $this.ValidateVolumeRange($mean, "MeanVolume")
        $this.ValidateVolumeRange($max, "MaxVolume")
        $this.ValidateVolumeRange($min, "MinVolume")

        $this.MeanVolume = $mean
        $this.MaxVolume = $max
        $this.MinVolume = $min
        $this.FixMeanVolume = $this.CalculateFixMeanVolume()
        $this.RequiresCompression = $this.DetermineCompressionNeed()
    }

    # Private method for volume validation
    hidden [void]ValidateVolumeRange([double]$value, [string]$paramName) {
        if ($value -lt -100.0 -or $value -gt 0.0) {
            throw [ArgumentException]::new(
                "Volume must be between -100.0 and 0.0 dB",
                $paramName
            )
        }
    }

    # Calculate adjusted mean volume with improvement factor
    hidden [double]CalculateFixMeanVolume() {
        # Enhanced algorithm for calculating fix mean volume
        $improvedVolume = $this.MeanVolume + 27.4
        
        # Ensure we don't exceed 0 dB
        return [Math]::Min($improvedVolume, 0.0)
    }

    # Determine if compression is needed based on volume metrics
    hidden [bool]DetermineCompressionNeed() {
        $dynamicRange = $this.MaxVolume - $this.MinVolume
        return $dynamicRange -gt 40.0 -or $this.MeanVolume -lt -24.0
    }

    # Public method to get volume analysis summary
    [hashtable]GetAnalysisSummary() {
        return @{
            MeanVolume = $this.MeanVolume
            MaxVolume = $this.MaxVolume
            MinVolume = $this.MinVolume
            FixMeanVolume = $this.FixMeanVolume
            DynamicRange = ($this.MaxVolume - $this.MinVolume)
            RequiresCompression = $this.RequiresCompression
        }
    }
}

# Audio file metadata class
class AudioFileMetadata {
    [string]$FilePath
    [AudioFileType]$FileType
    [ProcessingStage]$Stage
    [AudioVolumeStats]$VolumeStats
    [hashtable]$AdditionalMetadata

    # Constructor
    AudioFileMetadata([string]$path) {
        $this.FilePath = $path
        $this.FileType = $this.DetermineFileType($path)
        $this.Stage = [ProcessingStage]::Raw
        $this.AdditionalMetadata = @{}
    }

    # Determine file type from extension
    hidden [AudioFileType] DetermineFileType([string]$path) {
        $extension = [System.IO.Path]::GetExtension($path).ToLower()
        switch ($extension) {
            '.wav' { return [AudioFileType]::WAV }
            '.mp3' { return [AudioFileType]::MP3 }
            '.flac' { return [AudioFileType]::FLAC }
            default { return [AudioFileType]::Unknown }
        }

        # Failsafe return if no conditions match (this should never execute)
        return [AudioFileType]::Unknown
    }

    # Update volume stats
    [void]UpdateVolumeStats([AudioVolumeStats]$stats) {
        $this.VolumeStats = $stats
        $this.Stage = [ProcessingStage]::Analyzed
    }

    # Add or update additional metadata
    [void]AddMetadata([string]$key, [object]$value) {
        $this.AdditionalMetadata[$key] = $value
    }

    # Get full metadata summary
    [hashtable]GetMetadataSummary() {
        return @{
            FilePath = $this.FilePath
            FileType = $this.FileType.ToString()
            Stage = $this.Stage.ToString()
            VolumeStats = if ($this.VolumeStats) {
                $this.VolumeStats.GetAnalysisSummary()
            } else {
                $null
            }
            AdditionalMetadata = $this.AdditionalMetadata.Clone()
        }
    }
}

# Export public types
Export-ModuleMember -Function *
```

---

## /auto-audio-mixer-v2/src/Core/Utils/

## /auto-audio-mixer-v2/src/Core/Utils/ErrorHandling.psm1

```psm1
# /src/Core/Utils/ErrorHandling.psm1
using namespace System.Management.Automation

function Test-FFmpegAvailable {
    [CmdletBinding()]
    [OutputType([bool])]
    param()

    begin {
        Write-Verbose "Checking FFmpeg availability"
    }

    process {
        try {
            # Try to get FFmpeg version info
            $ffmpegVersion = & ffmpeg -version
            if ($LASTEXITCODE -eq 0 -and $ffmpegVersion) {
                Write-Verbose "FFmpeg found and working"
                return $true
            }
            Write-Warning "FFmpeg command executed but returned unexpected results"
            return $false
        }
        catch {
            Write-Warning "FFmpeg not found or not accessible: $_"
            return $false
        }
    }
}

function Test-FFmpegCapabilities {
    [CmdletBinding()]
    [OutputType([hashtable])]
    param()

    process {
        $capabilities = @{
            HasFFmpeg = $false
            HasVolumeDetect = $false
            HasCompressor = $false
            Version = $null
        }

        try {
            # Check basic FFmpeg availability
            $versionOutput = & ffmpeg -version 2>&1
            if ($LASTEXITCODE -eq 0) {
                $capabilities.HasFFmpeg = $true
                
                # Extract version
                if ($versionOutput -match 'ffmpeg version (\S+)') {
                    $capabilities.Version = $matches[1]
                }

                # Check for volume detection capability
                $filterOutput = & ffmpeg -filters 2>&1
                if ($filterOutput -match 'volumedetect') {
                    $capabilities.HasVolumeDetect = $true
                }

                # Check for compressor capability
                if ($filterOutput -match 'acompressor') {
                    $capabilities.HasCompressor = $true
                }
            }
        }
        catch {
            Write-Warning "Error checking FFmpeg capabilities: $_"
        }

        return $capabilities
    }
}

# Custom error types
class AudioProcessingError : Exception {
    [string]$Operation
    [string]$FilePath
    [datetime]$Timestamp

    AudioProcessingError([string]$message, [string]$operation, [string]$filePath) : base($message) {
        $this.Operation = $operation
        $this.FilePath = $filePath
        $this.Timestamp = [datetime]::Now
    }
}

class AudioAnalysisError : AudioProcessingError {
    AudioAnalysisError([string]$message, [string]$filePath) : base($message, "Analysis", $filePath) { }
}

class AudioCompressionError : AudioProcessingError {
    AudioCompressionError([string]$message, [string]$filePath) : base($message, "Compression", $filePath) { }
}

# Error handling functions
function Write-ErrorLog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [Exception]$Exception,

        [Parameter(Mandatory = $false)]
        [string]$LogPath = ".\errors.log",

        [Parameter(Mandatory = $false)]
        [switch]$PassThru
    )

    process {
        try {
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $errorType = $Exception.GetType().Name
            $message = $Exception.Message
            $stack = $Exception.StackTrace

            # Format error details
            $errorLog = @{
                Timestamp = $timestamp
                ErrorType = $errorType
                Message = $message
                StackTrace = $stack
            }

            # Add additional info for custom error types
            if ($Exception -is [AudioProcessingError]) {
                $errorLog.Operation = $Exception.Operation
                $errorLog.FilePath = $Exception.FilePath
            }

            # Convert to JSON for structured logging
            $jsonError = $errorLog | ConvertTo-Json

            # Ensure directory exists
            $logDir = Split-Path -Parent $LogPath
            if (-not [string]::IsNullOrEmpty($logDir) -and -not (Test-Path $logDir)) {
                New-Item -ItemType Directory -Path $logDir -Force | Out-Null
            }

            # Append to log file
            Add-Content -Path $LogPath -Value $jsonError

            # Write to error stream
            Write-Error -Exception $Exception -ErrorAction Continue

            # Return exception if PassThru is specified
            if ($PassThru) {
                return $Exception
            }
        }
        catch {
            Write-Error "Failed to log error: $_"
            if ($PassThru) {
                return $Exception
            }
        }
    }
}

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,

        [Parameter(Mandatory = $false)]
        [string]$ErrorMessage = "Operation failed",

        [Parameter(Mandatory = $false)]
        [string]$Operation = "Unknown",

        [Parameter(Mandatory = $false)]
        [string]$FilePath = "",

        [Parameter(Mandatory = $false)]
        [switch]$ContinueOnError
    )

    process {
        try {
            return & $ScriptBlock
        }
        catch {
            $exception = if ($_.Exception -is [AudioProcessingError]) {
                $_.Exception
            }
            else {
                [AudioProcessingError]::new(
                    "$ErrorMessage`: $($_.Exception.Message)",
                    $Operation,
                    $FilePath
                )
            }

            Write-ErrorLog -Exception $exception

            if (-not $ContinueOnError) {
                throw $exception
            }
        }
    }
}

# Export public functions
Export-ModuleMember -Function @(
    'Test-FFmpegAvailable',
    'Test-FFmpegCapabilities',
    'Write-ErrorLog',
    'Invoke-WithErrorHandling'
)
```

---

## /auto-audio-mixer-v2/src/IO/

## /auto-audio-mixer-v2/src/IO/FileSystem.psm1

*[No content available]*

---

## /auto-audio-mixer-v2/src/IO/MetadataManager.psm1

```psm1
# /src/IO/MetadataManager.psm1
using namespace System.Management.Automation

function Save-AudioMetadata {
    [CmdletBinding()]
    [OutputType([string])]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $_ -PathType Container })]
        [string]$FolderPath,

        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [hashtable]$MetadataCollection
    )

    process {
        try {
            $outputPath = Join-Path $FolderPath "metadata_output.json"
            $MetadataCollection | ConvertTo-Json -Depth 10 | Out-File -FilePath $outputPath -Encoding utf8
            Write-Verbose "Metadata saved to $outputPath"
            return $outputPath
        }
        catch {
            Write-Error "Error saving metadata: $_"
            return $null
        }
    }
}

function Update-AudioMetadata {
    [CmdletBinding()]
    [OutputType([bool])]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $_ -PathType Leaf })]
        [string]$JsonPath,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$FileName,

        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [hashtable]$NewMetadata
    )

    process {
        try {
            $existingMetadata = Get-Content $JsonPath | ConvertFrom-Json | ConvertTo-Hashtable
            $existingMetadata[$FileName] = $NewMetadata

            $existingMetadata | ConvertTo-Json -Depth 10 | Out-File -FilePath $JsonPath -Encoding utf8
            Write-Verbose "Metadata updated for $FileName in $JsonPath"
            return $true
        }
        catch {
            Write-Error "Error updating metadata: $_"
            return $false
        }
    }
}

Export-ModuleMember -Function Save-AudioMetadata, Update-AudioMetadata

```

---

## /auto-audio-mixer-v2/tests/

## /auto-audio-mixer-v2/tests/Audio/

## /auto-audio-mixer-v2/tests/Audio/Analysis/

## /auto-audio-mixer-v2/tests/Audio/Analysis/MetadataAnalyzer.Tests.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/tests/Audio/Analysis/VolumeAnalyzer.Tests.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/tests/Audio/Processing/

## /auto-audio-mixer-v2/tests/Audio/Processing/Compressor.Tests.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/tests/Configuration/

## /auto-audio-mixer-v2/tests/Configuration/Settings.Tests.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/tests/Core/

## /auto-audio-mixer-v2/tests/Core/Types/

## /auto-audio-mixer-v2/tests/Core/Types/AudioTypes.Tests.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/tests/Core/Utils/

## /auto-audio-mixer-v2/tests/Core/Utils/ErrorHandling.Tests.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/tests/IO/

## /auto-audio-mixer-v2/tests/IO/FileSystem.Tests.ps1

*[No content available]*

---

## /auto-audio-mixer-v2/tests/IO/MetadataManager.Tests.ps1

*[No content available]*

---


